---
title: web缓存
---

### web缓存
```
缓存可以解决的问题：

1）减少不必要的网络传输，节约宽带（省钱)
2）更快的加载页面
3）减少服务器压力

缺点：
1）占内存
```

web缓存：分为 <font color="#dd0000">浏览器缓存</font>和<font color="#dd0000">http缓存</font>

```
浏览器缓存： 
localStorage sessionStorage cookie , localStorage sessionStorage只能保持5M左右数据  cookie大概是4kb的数据
```

## 重点讲http缓存
<font color="#dd0000">(http缓存：分为两种缓存，强制缓存和协商缓存)</font>

 ##### 1. 强缓存

```
 在以前是会使用响应头的expires字段去实现强缓存，现在是使用Cache-Control

1) 不使用expires的原因
    1)
     使用的是一个强缓存的时间，服务器获取当前时间 （new Date("2022-11-21 23:59:59") ）返回，后面请求，用本地当前时间和服务器返回时间对比，看是否过期（漏洞：如果我本地时间不准咋办）
    2）Expires过度依赖本地时间，如果本地与服务器时间不同步，就会出现资源无法被缓存或者资源永远被缓存的情况。所以，Expires字段几乎不被使用了。现在的项目中，我们并不推荐使用Expires，强缓存功能通常使用cache-control字段来代替Expires字段。


2) 使用Cache-control

 Cache-Control:max-age=N，N是多少秒，设置返回资源可以缓存多长时间，从第一次请求资源得时候开始，往后在时间内就取磁盘或者内存数据，不与服务器交互（不需要和expires一样，用服务器返回得时间和客户端得时间做对比。解决了巨大漏洞）
  

```
###### Cache-Control 六大属性
+ [max-age] 决定客户端数据缓存多久 单位是秒
+ [s-maxage] 决定代理服务器缓存的时长
+ [no-cache] 表示强制进行协商缓存
+ [no-store] 表示禁止任何缓存策略
+ [public] 表示资源即可以被浏览器缓存也可以被代理服务器缓存
+ [private] 表示资源只能被浏览器缓存

注意，no-cache和no-store是一组互斥属性，这两个属性不能同时出现在Cache-Control中。
注意，public和private也是一组互斥属性。他们两个不能同时出现在响应头的cache-control字段中。

---
 ##### 2. 协商缓存

 ```
    没有命中强制缓存，进入协商缓存

    1）不推荐使用，但不能完全被替代 last-modified和If-Modified-Since
     响应头添加last-modified（服务器文件修改时间 ，最小单位是秒） ,请求头添加If-Modified-Since（服务器返回得修改时间） 第一次请求返回文件修改时间，后面每次请求都会带上If-Modified-Since这个字段，而务端就需要拿到这个时间并再次读取该资源的修改时间，让他们两个做一个比对来决定是读取缓存还是返回新的资源
     
       漏洞： 
        1） 是根据修改时间来判断得，如果文件本身没有修改，仍然有可能更新文件得修改时间（比如修改文件名再修改回来),这样文件没有修改，但缓存失效
        2） 当文件在极短时间内完成修改的时候（比如几百毫秒）。因为文件修改时间记录的最小单位是秒，所以，如果文件在几百毫秒内完成修改的话，文件修改时间不会改变，这样，即使文件内容修改了，依然不会 返回新的文件。


    2）使用Etag和is-None-Match
      
       1.第一次请求某资源的时候，服务端读取文件并计算出文件指纹，将文件指纹放在响应头的etag字段中跟资源一起返回给客户端。

       2.第二次请求某资源的时候，客户端自动从缓存中读取出上一次服务端返回的ETag也就是文件指纹。并赋给请求头的if-None-Match字段，让上一次的文件指纹跟随请求一起回到服务端。

       3.服务端拿到请求头中的is-None-Match字段值，并再次读取目标资源并生成文件指纹，两个指纹做对比。如果两个文件指纹完全吻合，说明文件没有被改变，则直接返回304状态码和一个空的响应体并return。如果两个文件指纹不吻合，则说明文件被更改，那么将新的文件指纹重新存储到响应头的ETag中并返回给客户端

      弊端： ETag需要计算文件指纹这样意味着，服务端需要更多的计算开销。。如果文件尺寸大，数量多，并且计算频繁，那么ETag的计算就会影响服务器的性能

     
 ```
<font color="#dd0000">
注意：cache-control是expires的完全替代方案(说人话:能用cache-control就不要用expiress)
    ETag并不是last-modified的完全替代方案。而是last-modified的补充方案（说人话：项目中到底是用ETag还是last-modified完全取决于业务场景，这两个没有谁更好谁更坏）。
</font>

###### 如何设置缓存
```
缓存是缓存在前端，但实际上代码是后端的同学来写的。如果你需要实现前端缓存的话啊，通知后端的同学加响应头就好了。
```

总结就是标注（从内存中读取/从磁盘中读取）的资源 都是缓存
响应状态码200是强缓存，304是协商缓存