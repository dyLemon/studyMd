## 防抖

> 在定时器内重复做一件事，会把之前的定时器清除，重新开始记时间

```
场景：

1.搜索框搜索输入，只需用户最后一次输入完，再发送请求

2.改变窗口大小resize,窗口调整完了才计算窗口的大小

3.鼠标的移入移出
```

## 节流

> 在定时器内重复做一件事，在这段时间内，只执行一次，不会像防抖一样清除重新开始

```
场景：

1.页面滚动加载

2.高频的点击提交，表单重复提交

```

## 浏览器缓存机制--强缓存和协商缓存

> xmind

## 页面的回流（重排）和重绘

```
 回流: 当改变 DOM 元素位置或大小时，会导致浏览器重新生成渲染树，这个过程叫重排
 重绘：页面中元素发生可见性变化(比如颜色等)，导致页面重新渲染的现象称为重绘。
 回流一定重绘，重绘不一定回流
```

## 资源懒加载

## 降低 css 选择器的复杂性（css 读取选择器 从右向左)

## css 放头部,js 放底部

```
如果这些 CSS、JS 标签放在 HEAD 标签里，并且需要加载和解析很久的话，那么页面就空白了。所以 JS 文件要放在底部（不阻止 DOM 解析，但会阻塞渲染），等 HTML 解析完了再加载 JS 文件，尽早向用户呈现页面的内容。
即先执行head标签里的内容，再执行body标签里的，一行行渲染下去。碰到头部有js文件引用时，浏览器就会开始下载这个js文件，下载后再执行，执行完毕后再继续解析后面的html。如果这个js文件很大，需要两秒来下载，那么浏览器就会停下来两秒，势必会影响用户体验。所以原则就是尽可能快地让首屏内容先展现，再加载其他资源

那为什么 CSS 文件还要放在头部呢？
因为先加载 HTML 再加载 CSS，会让用户第一时间看到的页面是没有样式的、“丑陋”的，为了避免这种情况发生，就要将 CSS 文件放在头部了。
另外，JS 文件也不是不可以放在头部，只要给 script 标签加上 defer 属性就可以了，异步下载，延迟执行。
```

## 使用字体图标 iconfont 代替图片图标

## 压缩文件

```

 压缩文件可以减少文件下载时间，让用户体验性更好。
 得益于 webpack 和 node 的发展，现在压缩文件已经非常方便了。
 在 webpack 可以使用如下插件进行压缩：
JavaScript：UglifyPlugin
CSS ：MiniCssExtractPlugin
HTML：HtmlWebpackPlugin
```


### base64编码
```

```